/*
 * HnString.cc
 *
 * DO NOT EDIT THIS FILE!
 *
 * This file is automatically generated by obj2ptr.
 * 1997/06/02 21:18:59
 */

#include "HnString.hh"
#include "HnStringObj.hh"

/*
 * HnString
 */

const HnString HnString::null;

HnString
new_HnString(void)
{
	HnStringObj *_obj;
	HnString _ptr;

	_obj = new HnStringObj();

	if(_obj->hasFailed())
		return HnString::null;

	_ptr.assign(_obj);
	return _ptr;
}

HnString
new_HnString(const char *ptr, int n)
{
	HnStringObj *_obj;
	HnString _ptr;

	_obj = new HnStringObj(ptr, n);

	if(_obj->hasFailed())
		return HnString::null;

	_ptr.assign(_obj);
	return _ptr;
}

HnString
new_HnString(const HnString &string)
{
	HnStringObj *_obj;
	HnString _ptr;

	_obj = new HnStringObj(string);

	if(_obj->hasFailed())
		return HnString::null;

	_ptr.assign(_obj);
	return _ptr;
}

const char *
HnString::chars(void) const
{
	return getObject()->chars();
}

const char &
HnString::get(int i) const
{
	return getObject()->get(i);
}

const char &
HnString::operator[](int i) const
{
	return getObject()->operator[](i);
}

int
HnString::length(void) const
{
	return getObject()->length();
}

HnString
HnString::concat(const char *ptr, int n) const
{
	return getObject()->concat(ptr, n);
}

HnString
HnString::concat(const char *ptr) const
{
	return getObject()->concat(ptr);
}

HnString
HnString::concat(const HnString &string) const
{
	return getObject()->concat(string);
}

HnBool
HnString::equals(const HnString &ptr) const {
	if(isInvalid()) {
		if(ptr.isInvalid())
			return HnTRUE;
		else
			return HnFALSE;
    	}
    	else {
		if(ptr.isInvalid())
			return HnFALSE;
		else
			return getObject()->equals(ptr);
	}
}

HnBool
HnString::startsWith(const char *prefix, int n) const
{
	return getObject()->startsWith(prefix, n);
}

HnBool
HnString::startsWith(const char *prefix) const
{
	return getObject()->startsWith(prefix);
}

HnBool
HnString::startsWith(const HnString &string) const
{
	return getObject()->startsWith(string);
}

HnBool
HnString::endsWith(const char *suffix, int n) const
{
	return getObject()->endsWith(suffix, n);
}

HnBool
HnString::endsWith(const char *suffix) const
{
	return getObject()->endsWith(suffix);
}

HnBool
HnString::endsWith(const HnString &string) const
{
	return getObject()->endsWith(string);
}

int
HnString::indexOf(int ch, int fromIndex) const
{
	return getObject()->indexOf(ch, fromIndex);
}

int
HnString::indexOf(int ch) const
{
	return getObject()->indexOf(ch);
}

int
HnString::lastIndexOf(int ch, int fromIndex) const
{
	return getObject()->lastIndexOf(ch, fromIndex);
}

int
HnString::lastIndexOf(int ch) const
{
	return getObject()->lastIndexOf(ch);
}

HnString
HnString::substring(int beginIndex, int endIndex) const
{
	return getObject()->substring(beginIndex, endIndex);
}

HnString
HnString::substring(int beginIndex) const
{
	return getObject()->substring(beginIndex);
}

HnString
HnString::trim(void) const
{
	return getObject()->trim();
}

HnString
HnString::getString(FILE *fp)
{
	return HnStringObj::getString(fp);
}

HnStringArray
HnString::sort(const HnStringArray &strings)
{
	return HnStringObj::sort(strings);
}

void
HnString::escape(const char *ptr, HnString *string_return)
{
	HnStringObj::escape(ptr, string_return);
}

void
HnString::unescape(const char *ptr, HnString *string_return)
{
	HnStringObj::unescape(ptr, string_return);
}

void
HnString::pack(const HnStringArray &strings, HnString *string_return)
{
	HnStringObj::pack(strings, string_return);
}

void
HnString::unpack(const char *ptr, HnStringArray *strings_return)
{
	HnStringObj::unpack(ptr, strings_return);
}

void
HnString::pack(const char *array[], int length, HnString *string_return)
{
	HnStringObj::pack(array, length, string_return);
}

void
HnString::pack(const char *ptr1, HnString *string_return)
{
	HnStringObj::pack(ptr1, string_return);
}

void
HnString::unpack(const char *ptr, HnString *string1_return)
{
	HnStringObj::unpack(ptr, string1_return);
}

void
HnString::pack(const char *ptr1, const char *ptr2, HnString *string_return)
{
	HnStringObj::pack(ptr1, ptr2, string_return);
}

void
HnString::unpack(const char *ptr, HnString *string1_return, HnString *string2_return)
{
	HnStringObj::unpack(ptr, string1_return, string2_return);
}

void
HnString::pack(const char *ptr1, const char *ptr2, const char *ptr3, HnString *string_return)
{
	HnStringObj::pack(ptr1, ptr2, ptr3, string_return);
}

void
HnString::unpack(const char *ptr, HnString *string1_return, HnString *string2_return, HnString *string3_return)
{
	HnStringObj::unpack(ptr, string1_return, string2_return, string3_return);
}

void
HnString::pack(const char *ptr1, const char *ptr2, const char *ptr3, const char *ptr4, HnString *string_return)
{
	HnStringObj::pack(ptr1, ptr2, ptr3, ptr4, string_return);
}

void
HnString::unpack(const char *ptr, HnString *string1_return, HnString *string2_return, HnString *string3_return, HnString *string4_return)
{
	HnStringObj::unpack(ptr, string1_return, string2_return, string3_return, string4_return);
}

/*
 * HnStringArrayObj
 */

#include <stdlib.h>
class HnStringArrayObj: public HnObject {
private:
	HnString **array;
	int len;
	int size;

	static const int initialSize;

	void initialize(void) {
		array = NULL;
		len = 0;
		size = 0;
	}
	void dispose(void) {
		if(array != NULL) {
			int i;
			for(i=0; i<len; i++)
				delete array[i];
			free(array);
		}
		array = NULL;
		len = 0;
		size = 0;
	}
	void ensureSize(int requiredSize);

public:
	/* constructor and destructor */
	HnStringArrayObj(void);
	HnStringArrayObj(const HnStringArray &ptr);
	~HnStringArrayObj(void);

	/* clear, append, insert, and remove */
	void clear(void);
	void append(const HnString &ptr);
	void append(const HnStringArray &ptr);
	void insert(const HnString &ptr, int index);
	HnString remove(int index);
	void set(const HnString &ptr, int index);
	void swap(int i, int j);

	/* length and get */
	int length(void) const { return len; }
	HnString &get(int i) const;

	/* utilities */
	HnBool equals(const HnStringArray &ptr) const;
	int indexOf(const HnString &ptr, int fromIndex) const;
	HnString toString(void) const;
};

const int HnStringArrayObj::initialSize = 4;

static void *
xrealloc(void *ptr, size_t size)
{
        if(ptr == NULL) {
                if((ptr = malloc(size)) == NULL)
                        HnSysError("malloc");
        }
        else {
                if((ptr = realloc(ptr, size)) == NULL)
                        HnSysError("realloc");
        }

        return ptr;
}

void
HnStringArrayObj::ensureSize(int requiredSize)
{
	int oldSize, newSize;

	if((oldSize = size) >= requiredSize)
		return;

	if((newSize = oldSize) == 0)
		newSize = initialSize;

	while(newSize < requiredSize)
		newSize *= 2;

	array = (HnString **)xrealloc(array, sizeof(HnString *) * newSize);

	size = newSize;
}

HnStringArrayObj::HnStringArrayObj(void)
{
	initialize();
}

HnStringArrayObj::HnStringArrayObj(const HnStringArray &ptr)
{
	initialize();

	clear();
	append(ptr);
}

HnStringArrayObj::~HnStringArrayObj(void)
{
	dispose();
}

void
HnStringArrayObj::clear(void)
{
	dispose();
}

void
HnStringArrayObj::append(const HnString &ptr)
{
	ensureSize(len + 1);

	array[len] = new HnString(ptr);
	len ++;
}

void
HnStringArrayObj::append(const HnStringArray &ptr)
{
	int i;

	ensureSize(len + ptr.length());

	for(i=0; i<ptr.length(); i++)
		append(ptr[i]);
}

void
HnStringArrayObj::insert(const HnString &ptr, int index)
{
	if(index < 0 || index > len)
		HnAbort("HnStringArrayObj::insert: "
			"index is out of bounds.");

	ensureSize(len + 1);

	memmove(array + index + 1, array + index,
		sizeof(HnString *) * (len - index));

	array[index] = new HnString(ptr);
	len ++;
}

HnString
HnStringArrayObj::remove(int index)
{
	HnString ptr = get(index);

	if(index < 0 || index >= len)
                HnAbort("HnStringArrayObj::remove: "
			"index is out of bounds.");

	delete array[index];

	memmove(array + index, array + index + 1,
		sizeof(HnString *) * (len - index - 1));
	len --;

	return ptr;
}

void
HnStringArrayObj::set(const HnString &ptr, int index)
{
	if(index < 0 || index >= len)
		HnAbort("HnStringArrayObj::set: "
			"index is out of bounds.");

	delete array[index];

	array[index] = new HnString(ptr);
}

void
HnStringArrayObj::swap(int i, int j)
{
	if(i < 0 || i >= len || j < 0 || j >= len)
		HnAbort("HnStringArrayObj::swap: index is out of bounds.");

	HnString *ptr = array[i];
	array[i] = array[j];
	array[j] = ptr;
}

HnString &
HnStringArrayObj::get(int i) const {
	if(i < 0 || i >= len)
		HnAbort("HnStringArrayObj::get: index is out of bounds.");

	return *array[i];
}

HnBool
HnStringArrayObj::equals(const HnStringArray &ptr) const {
	int i;

	if(len != ptr.length())
		return HnFALSE;

	for(i=0; i<len; i++) {
		if(!array[i]->equals(ptr[i]))
			return HnFALSE;
	}

	return HnTRUE;
}

int
HnStringArrayObj::indexOf(const HnString &ptr, int fromIndex) const
{
	int i;

	for(i=fromIndex; i<len; i++) {
		if(array[i]->equals(ptr))
			return i;
	}

	return -1;
}

HnString
HnStringArrayObj::toString(void) const
{
	HnString string;

	string = "[ ";
	for(int i=0; i<len; i++) {
		if(i != 0)
			string += ", ";
		string += array[i]->toString();
	}
	string += " ]";

	return string;
}

/*
 * HnStringArray
 */

const HnStringArray HnStringArray::null;

HnStringArray
new_HnStringArray(void)
{
	HnStringArray ptr;

        ptr.assign(new HnStringArrayObj());
        return ptr;
}

HnStringArray
new_HnStringArray(const HnStringArray &value)
{
	HnStringArray ptr;

        if(value.isInvalid())
                ptr.assign(NULL);
        else
                ptr.assign(new HnStringArrayObj(value));

        return ptr;
}

void
HnStringArray::clear(void)
{
	getObject()->clear();
}

void
HnStringArray::append(const HnString &ptr)
{
	getObject()->append(ptr);
}

void
HnStringArray::append(const HnStringArray &ptr)
{
	getObject()->append(ptr);
}

void
HnStringArray::insert(const HnString &ptr, int index)
{
	getObject()->insert(ptr, index);
}

HnString
HnStringArray::remove(int index)
{
	return getObject()->remove(index);
}

void
HnStringArray::set(const HnString &ptr, int index)
{
	getObject()->set(ptr, index);
}

void
HnStringArray::swap(int i, int j)
{
	getObject()->swap(i, j);
}

int
HnStringArray::length(void) const
{
	return getObject()->length();
}

HnString &
HnStringArray::get(int i) const
{
	return getObject()->get(i);
}

HnBool
HnStringArray::equals(const HnStringArray &ptr) const
{
	return getObject()->equals(ptr);
}

int
HnStringArray::indexOf(const HnString &ptr, int fromIndex) const
{
	return getObject()->indexOf(ptr, fromIndex);
}

HnString
HnStringArray::toString(void) const
{
	return getObject()->toString();
}

